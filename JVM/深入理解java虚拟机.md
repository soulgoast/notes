# 深入理解java虚拟机

> 为什么要学习java虚拟机

## Java语言的特性

- 结构严谨（简单）：ava语法是C++语法的一个“纯净版本”。**这里没有**头文件，指针运算（甚至指针语法），结构，联合，操作符重载，虚基类等等。不仅如此，Java开发环境远远超出大多数其他编程语言的开发环境。
- 面向对象：什么是面向对象？用木匠打一个比方，一个“面向对象”的木匠始终关注的是所制作的椅子，第二位才是所使用的工具；而一个“非面向对象”木匠首先考虑的是所使用的工具。
- 平台无关：Write One， Run AnyWhere（一次编译，到处运行）
- 网络移动性：
- 安全：内存管理和访问机制
- 动态性：动态连接、动态扩展

Java 程序的执行流程



## Java内存区域与OOM



- 
- Java虚拟机内存的各个区域
- 这些区域的作用、服务的对象
- 可能产生的问题

![QQ截图20170616160709](https://images2015.cnblogs.com/blog/1182497/201706/1182497-20170616192740650-1039521219.png)

​			



## Java虚拟机的类加载机制

> 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行连接（验证、准备、解析）和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

:key:类加载都是在程序运行期间完成的

在解释这句话之前，先来回顾一些java的特性，其中动态性就是依赖java的类加载机制完成的。什么是动态性？

动态扩展就是Java的体系结构允许动态扩展Java程序，这个过程包括运行时决定所使用的类型，装载它们，使用它们。

面向接口编程，spring的IOC容器

动态扩展的方式

Class.forName

类状态器的loadClass方法





:partly_sunny:加载class文件的方式

- 从本地本地文件系统中
- 从归档文件jar包中
- 通过网络下载class文件（java最早提供的applet是给浏览器使用的，现在某些浏览器还是可以运行，不过由于存在安全漏洞，所以）

- 从专有数据库中提取.class文件
- 将Java源文件动态编译为.class文件：动态代理，JSP->Servlet

:sun_with_face:数据的校验：服务端校验

我们知道



判断类型的加载阶段的方法：

未被加载：删除class文件，程序是否能够正常执行

已被加载，但是未被初始化：通过打印日志

已初始化：验证初始化是数据

助记符

验证的类型

编译器常量

运行期常量

数组

类加载器的准备阶段和初始化阶段的重要意义

接口













- 基于JVM的各种动态与静态语言生态圈

> JVM上运行的并不是.java的文件，而是.java的文件通过编译生成的.class文件。.class也就是java字节码文件，只要是通过编译能够生成.class文件，那么该文件就能运行在java虚拟机上。.class文件是有一个规范的，JVM是可以读懂.class文件，通过校验后，就能运行.class文件。运行在JVM上的动态语言有，静态语言有：

- JVM介绍
- Oracle：HotSpot虚拟机讲解
- 垃圾收集方式详解
- 垃圾收集算法详解
- 垃圾收集器详解
- 分代垃圾收集机制详解
- 新生代讲解
- 老年代讲解
- G1收集器分析与实例
- 栈
- 方法区
- 线程共享内存区
- 根搜索算法
- Serial收集器
- ParNew收集器

## 类加载机制详解

**在Java中，类型（class,interface）的加载、连接与初始化过程都是在程序运行期间完成的。**

### 类加载器

用于加载类型的工具

### 加载：查找并加载类的二进制数据

最常见的一种就是将编译好的class文件加载到内存中。

类的加载植地是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区内的数据结构。

### 连接

验证：确保被加载类的正确性

准备：为类的**静态变量**分配内存，并将其初始化为**默认值**

解析: 将类中的**符号引用**转换为**直接引用**

### 初始化：为类的静态变量赋予正确的初始值

### 使用

### 卸载：OSGI

🐷mian函数的加载过程



🐷符号引用

Java程序对类的使用方式分为两种

- 主动使用：**字节码助记符**
  - 创建类的实例
  - 访问某个类或接口的静态变量，或者对该静态变量赋值
  - 调用类的静态方法
  - 反射（如Class.forName("com.test.Test")）
  - 初始化一个类的子类
  - Java虚拟机启动时，被标明启动类的类
  - JDK1.7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化
- 被动使用：除了以上七种情况，其他使用Java类的方式都被看做时对类的被动使用，都不会导致类的初始化。

所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才初始化他们



加载.class文件的方式

- 从本地系统中直接加载
- 通过网络下载.class文件
- 从zip,jar等归档文件中加载.class文件
- 从专有数据库中提取.class文件
- 将Java源文件动态编译为.class文件：动态代理，JSP->Servlet





对一些静态变量进行赋值

java虚拟机与程序的生命周期

在如下情况下，Java虚拟机将结束生命周期

1. 执行了System.exit()方法
2. 程序正常执行结束
3. 程序在执行过程中遇到了异常或错误而异常终止
4. 由于操作系统出现错误而导致Java虚拟机进程终止

- 
- 类加载的双亲委托机制

根类加载器——》扩展类加载器——》系统类加载器——》用户自定义类加载器

双亲委托机制：

Bootstrap ClassLoader：启动类加载器，加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类。

ExtensionClassLoader:扩展类加载器，负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar里所有的class或者-Djava.ext.dirs指定目录下的jar包

APP ClassLoader：系统类加载器，负责加载classpath中指定的jar包及目录中class







- 字节码文件生成与分析
- 魔数
- 常量池与方法区
- 各种指令详解
- 锁详解
- 线程安全
- 偏向锁、自旋锁与轻量级锁
- JIT编译器
- GC日志生成与分析
- 虚拟机监控工具
- Jconsole使用方式详解
- 为何逃逸与逃逸分析
- 方法内联
- 虚拟机内存模型详解



# 走进Java

java的特性

1. 结构严谨、面向对象的编程语言
2. 摆脱了平台的束缚，实现"一次编写，到处运行"的理想
3. 提供了相对安全的内存管理和访问机制，避免了绝大部分的内存泄露和指针越界的问题。
4. 实现了热点代码检测和运行时编译及优化，这使得Java应用能随着运行时间的增加而获得更高的性能。
5. 拥有一套完善的应用程序接口。
6. 拥有无数来自商业机构和开源社区的第三方类库来帮助它实现各种各样的功能。

Java技术体系的组成部分

1. Java程序设计语言
2. 各种平台上的Java虚拟机
3. Class文件格式
4. JavaAPI类库
5. 来自开源机构和开源社区的第三方Java类库

Java的发展历史：

1. java 1.0：Java虚拟机（Sun Classic VM）、Applet、AWT。主要来做页面应用。
2. java 1.1：JAR文件格式、JDBC、JavaBeans、RMI、Java语法（内部类Inner Class、反射Reflection）
3. java 1.2：EJB、Java Plug-in、Java IDL、Swing、内置JIT、strictfp、Collections集合类
4. java1.3:数学运算、Timer API
5. java1.4：正则表达式、异常链、NIO、日志类、XML解析器、XSLT转换器
6. java1.5：语法（自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环）、改进内存模型，提供concurrent包
7. java1.6：

Java技术的未来：

1. 模块化

# 第二章   Java内存区域与内存溢出异常

1. 垃圾收集器
2. 分代收集算法：新生代和老年代
3. Eden空间、From Survivor空间、To Survivor空间
4. 

# 第三章   垃圾回收器与内存分配策略

1. 哪些内存需要收集？
2. 什么时候收回？
3. 如何收回？
4. 

# 第四章   虚拟机性能监控与故障处理工具

# 第五章   调优案例分析与实战

# 第五章	高效并发

## Java内存模型与线程

阿姆达尔定律：通过系统中并行化与串行化的比重来描述多处理器系统能获得的运算加速能力。

摩尔定律：用于描述处理器晶体管数量与运算效率之间的发展关系。



##### 存储与通信子系统的耗时操作

1. 磁盘I/O
2. 网路通信
3. 数据库访问



## 线程安全与锁优化





# FeiQ

1. 理解和使用内部类
2. 句柄
3. 字节码解释器
4. 逃逸分析技术
5. 栈上分配
6. 标量替换